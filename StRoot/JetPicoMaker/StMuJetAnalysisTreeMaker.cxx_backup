/*
  Author: Sevil Salur 2007
  Analysis code for the tree reconstruction for Jets...
  Added Mark's request April 2008
  Updated with Matuesz's "user friendly" classes See (TStarJetPico*) April 2008
*/

//
//  Include header files. 
#include "TFile.h"
#include "TTree.h"

#include "StMessMgr.h"
#include "TH1.h"
#include "TH2.h"
#include <TVector2.h>

//StEmc
#include "StEmcClusterCollection.h"
#include "StEmcPoint.h"
#include "StEmcUtil/geometry/StEmcGeom.h"
#include "StEmcUtil/others/emcDetectorName.h"
#include "StEmcADCtoEMaker/StBemcData.h"
#include "StEmcADCtoEMaker/StEmcADCtoEMaker.h"

#include "StEmcRawMaker/StBemcRaw.h"
#include "StEmcRawMaker/StBemcTables.h"
#include "StEmcRawMaker/StEmcRawMaker.h"
#include "StEmcRawMaker/defines.h"

#include "tables/St_emcStatus_Table.h"
#include "tables/St_smdStatus_Table.h"


#include "StMuDSTMaker/COMMON/StMuEmcCollection.h" 
#include "StEmcCollection.h"
#include "StEmcCluster.h"
#include "StMuDSTMaker/COMMON/StMuEmcPoint.h"
#include "StEmcUtil/projection/StEmcPosition.h"
#include "StEmcUtil/filters/StEmcFilter.h" 
//
#include "StEmcRawHit.h" 
#include "StEmcModule.h"  
#include "StEmcDetector.h" 
#include "StEmcClusterCollection.h"  
#include "StDaqLib/EMC/StEmcDecoder.h"

#include "tables/St_emcStatus_Table.h"
#include "tables/St_smdStatus_Table.h"

#include "StMuDSTMaker/COMMON/StMuEmcCollection.h"
#include "StMuDSTMaker/COMMON/StMuTrack.h"
#include "StMuDSTMaker/COMMON/StMuDst.h"
#include "StMuDSTMaker/COMMON/StMuDebug.h"
#include "StMuDSTMaker/COMMON/StMuPrimaryVertex.h"
#include "StMuDSTMaker/COMMON/StMuDstMaker.h"
#include "StEvent/StTriggerId.h"
#include "StTriggerUtilities/StTriggerSimuMaker.h"
#include "StTriggerUtilities/StTriggerSimuResult.h"
#include "StTriggerUtilities/Bemc/StBemcTriggerSimu.h"
#include "StTriggerUtilities/L2Emulator/StL2TriggerSimu.h"

#include "StStrangeMuDstMaker/StV0MuDst.hh"

#include "StMuJetAnalysisTreeMaker.h"

#include "TStMuCutEventJet.h"
#include "TStMuCutV0Jet.h"
//#include "eventStructure/TParticleTow.h"

#include "TStarJetPicoEvent.h"
#include "TStarJetPicoEventHeader.h"
#include "TStarJetPicoPrimaryTrack.h"
#include "TStarJetPicoTower.h"
#include "TStarJetPicoV0.h"
#include "TStarJetPicoTriggerInfo.h"

#include "TStarJetPicoDefinitions.h"
#include "TStarJetPicoQAHistograms.h"

#include "TStarJetPicoUtils.h"

//  Prototype 
void muEventInfo(StMuEvent&, const Int_t&);
ClassImp(StMuJetAnalysisTreeMaker)
  
  // The constructor. Initialize data members here.
  StMuJetAnalysisTreeMaker::StMuJetAnalysisTreeMaker(const Char_t *name) : StMaker(name)
{ 
  mEventCounter = 0;   
  mFile = 0; 
  fNHits=12;
  mGeom = StEmcGeom::instance("bemc");
  mFilter   = new StEmcFilter();  
  mTables   = new StBemcTables(); 
  rMatch    = 0; //counter for matched
  fMatchTrArr = 0;
  fMatchTrEtaArr = 0;
  fMatchTrPhiArr = 0;
  fPrimIndexArray = 0;
  fPrimEtaArray = 0;
  fPrimPhiArray = 0;


  doV0 = kTRUE;
  nV0s = 0;
  fTCutV0       = new TStMuCutV0Jet();
  fTCutV0->SetVerbose(0); 
  fNTOTMatchedTr=0;
  fMatchedTow=0;
  fTrigMap="2006-2008";
}

StMuJetAnalysisTreeMaker::~StMuJetAnalysisTreeMaker() { /* noop */ }
//
//  Called once at the beginning.
Int_t StMuJetAnalysisTreeMaker::Init()
{
 
  // QAHist = TStarJetPicoQAHistograms::Instance();

  cout << "open a root ouput file " << endl;
  mFile = new TFile(fFilename,"RECREATE","HistoFile");
 
  fTCutEvent       = new TStMuCutEventJet();
  fTCutEvent->SetVerbose(1); 

  /*  //QA Plots 

  // hEventRefMult =new TH1D("RefMult","",700,0,700);
 hEventVertexZ =new TH1D("VertexZ","",100,-50,50);
 hEventNPrim=new TH1D("NPrim","",700,0,700);
 hEventNPrimCut=new TH1D("NPrimCut","",700,0,700);
 hEventNTowers=new TH1D("NTowers","",1000,0,5000);
 hEventNTowersCut=new TH1D("NTowersCut","",1000,0,5000);
 //Track QA 
 hTrackNhits=new TH1D("PNhits","",50,0,50);
 hTrackNhitsCut=new TH1D("PNhitsCut","",50,0,50);
 hTrackDCA=new TH1D("PDCA","",50,-5,5);
 hTrackEta=new TH1D("PEta","",40,-2,2);
 hTrackPhi=new TH1D("PPhi","",40,-4,4);
 hTrackPoverE=new TH1D("PpoverE","",40,0,10);
 //Tower QA
 hTowerEta=new TH1D("TEta","",40,-2,2);
 hTowerEtaC=new TH1D("TEtaC","",40,-2,2);
 hTowerPhi=new TH1D("TPhi","",40,-4,4);
 hTowerET=new TH1D("TEneryT","",100,0,50);
 hNMatched=new TH1D("NMatched","",100,0,500);

 hNMatchedvsRefMult=new TH2D("NMatchedvsRefMult","",100,0,500,70,0,700);
 hPtvsEtMatched=new TH2D("PtvsEtMatched","",100,0,50,100,0,50);
 hEtaMEtaT=new TH2D("EtaMEtaT","",40,-2,2,40,-2,2);
 hPhiMPhiT=new TH2D("PhiMPhiT","",40,-2,2,40,-2,2);

  */



  if(nflagData==0){
    //AuAu GammaL2 
    fTCutEvent->SetStandardCutsAuAuL2();
    fTCutEvent->SetMult(0,700);
    fTCutEvent->SetVertexZ(-30,30);
  }


  if(nflagData==1){
    //AuAu MinBias 
    fTCutEvent->SetStandardCutsAuAuY7Min();
    fTCutEvent->SetMult(0,7000);
    fTCutEvent->SetVertexZ(-300,300);
  }

  if(nflagData==2){
    //CuCu 
    fTCutEvent->SetStandardCutsCuCuMinBias();//SetStandardCutsCuCuHighTrw() is currently set equivalent to MinBias
    fTCutEvent->SetMult(0,500);
    fTCutEvent->SetVertexZ(-30,30);
  }

  if(nflagData==3){
    //PP //---- Set the following cuts when choosing the following configurations 
    // fTCutEvent->SetStandardCutsPPMinBiasY6();
    // fTCutEvent->SetStandardCutsPPHTTPY6();
    // fTCutEvent->SetStandardCutsPPHT2Y6();
    // fTCutEvent->SetStandardCutsPPJP1mbY6();
    fTCutEvent->SetStandardCutsPPallY6();

    fTCutEvent->SetMult(0,200);
    fTCutEvent->SetVertexZ(-50,50);
  }
  if(nflagData==4){
    //dAu ALL
    fTCutEvent->SetStandardCutsdAuALLY8();
    fTCutEvent->SetMult(0,700);
    fTCutEvent->SetVertexZ(-30,30);
  }
  if(nflagData==5){
    //dAu HT
    fTCutEvent->SetStandardCutsdAuHTY8();
    fTCutEvent->SetMult(0,700);
    fTCutEvent->SetVertexZ(-30,30);
  }
  if(nflagData==6){
    //PYTHIA --> no trigger object stored
    fTCutEvent->SetStandardCutsMC();
    fTCutEvent->SetMult(0,200);
    fTCutEvent->SetVertexZ(-50,50);
  }

 if(nflagData==7){
   
    //AuAu MinBias 39 GeV
    fTCutEvent->SetStandardCutsAuAu39();
    fTCutEvent->SetMult(185,7000);
    fTCutEvent->SetVertexZ(-30,30);
    fNHits=20;
  }


 if(nflagData==8){
   
    //PP Y12 TOFMult4 200 GeV
    fTCutEvent->SetStandardCutsppY12();
    fTCutEvent->SetMult(0,7000);
    fTCutEvent->SetVertexZ(-50,50);
  }

  simuTrig = dynamic_cast<StTriggerSimuMaker*>(GetMaker("StarTrigSimu")); assert(simuTrig); //#ly

  cout<<"******** doing Init  **********"<<endl; 
  MEvent =0;
  mFile->cd();
  MTree=new TTree("JetTree"," Pico Tree for Jet");
  MTree->Branch("PicoJetTree","TStarJetPicoEvent",&MEvent);//,64000,2);
  MTree->SetAutoSave(100000);
  cout<<"******** end of Init Stage **********"<<endl; 

  //__DEBUG(2, Form("hkgfkutd %d", 5));

  return StMaker::Init();
}
//
//  Called every event after Make(). 
void StMuJetAnalysisTreeMaker::Clear(Option_t *opt)
{
  delete [] fMatchTrArr;fMatchTrArr=0;
  delete [] fMatchTrEtaArr;fMatchTrEtaArr=0;
  delete [] fMatchTrPhiArr;fMatchTrPhiArr=0;
  delete [] fPrimIndexArray; fPrimIndexArray=0;
  delete [] fPrimEtaArray; fPrimEtaArray=0;
  delete [] fPrimPhiArray; fPrimPhiArray=0;
  StMaker::Clear();
}
//
//  Called once at the end.
Int_t StMuJetAnalysisTreeMaker::Finish()
{
  //  Summarize the run.
  cout << "StMuJetAnalysisTreeMaker::Finish()\n";
  //    cout << "\tProcessed " << mEventCounter << " events." << endl;
  //
  
  mFile->cd();

  //  Write histos to file and close it.
  if( mFile){
    //  QAHist->WriteHistogramsToFile(mFile);
     mFile->Write();  
     mFile->Close();
  }

  return kStOK;
}
//
//  This method is called every event.
Int_t StMuJetAnalysisTreeMaker::Make()
{
  //  cout<<"EVENT = "<<mEventCounter<<endl;
  //   mEventCounter++;  // increase counter
  
  DEBUGVALUE2(mEventCounter);
  //  Get MuDst
  
  mu =  (StMuDst*) GetInputDS("MuDst"); 
  DEBUGVALUE2(mu);
  
  if (!mu){
    gMessMgr->Warning() << "StMuJetAnalysisTreeMaker::Make : No MuDst" << endm;
    return kStOK;        // if no event, we're done
  }
  //
  //  Check StMuEvent branch
 
  muEvent = (StMuEvent*) mu->event();

  
  if (!muEvent) {
    cout << "ReadStMuEvent() -- no event class???" << endl;
    return kStOK;
  }
  
  StMuPrimaryVertex* fprimaryVertex =  mu->primaryVertex();
  if (!fprimaryVertex) {
    cout << "StMuJetAnalysisTreeMaker::ReadStMuEvent() -- no PV ???" << endl;
    return kStOK;
  }
  
  //cout<<"PRIMARY VERTEX = "<<fprimaryVertex->position().x()<<"  "<<fprimaryVertex->position().y()<<"  "<<fprimaryVertex->position().z()<<"  "<<endl;
  PrimVertexZ=fprimaryVertex->position().z(); //for tower Eta correction due to z shift of the primary vertex



  //// check event
  if(fTCutEvent->CheckEvent(muEvent) != 1)
    { 
      cout<<" ### event not taken ### "<<endl;
      //      return kStOK;  
      return 0;
    }   
  
  cout<<"EVENT = "<<mEventCounter<<endl;
  mEventCounter++;  // increase counter
  
  MEvent=new TStarJetPicoEvent();


  if(nflagData==0 || nflagData==1){
    //AuAu GammaL2
    cout<<"AuAu Gamma L2 set or AuAu MinBias"<<endl; 
    if(muEvent->triggerIdCollection().nominal().isTrigger(200211)==1) MEvent->GetHeader()->AddTriggerId(200211);//bht2-mb
    if(muEvent->triggerIdCollection().nominal().isTrigger(200212)==1) MEvent->GetHeader()->AddTriggerId(200212);//bht2-mb
    if(muEvent->triggerIdCollection().nominal().isTrigger(200220)==1) MEvent->GetHeader()->AddTriggerId(200220);//bht2-mb
    if(muEvent->triggerIdCollection().nominal().isTrigger(200221)==1) MEvent->GetHeader()->AddTriggerId(200221);//bht2-mb
    if(muEvent->triggerIdCollection().nominal().isTrigger(200222)==1) MEvent->GetHeader()->AddTriggerId(200222);//bht2-mb

    if(muEvent->triggerIdCollection().nominal().isTrigger(200001)==1) MEvent->GetHeader()->AddTriggerId(200001);//mb-vpd//MinBias
    if(muEvent->triggerIdCollection().nominal().isTrigger(200003)==1) MEvent->GetHeader()->AddTriggerId(200003);//mb-vpd //MinBias
    if(muEvent->triggerIdCollection().nominal().isTrigger(200013)==1) MEvent->GetHeader()->AddTriggerId(200013);//mb-vpd //MinBias
   
    if(muEvent->triggerIdCollection().nominal().isTrigger(200620)==1) MEvent->GetHeader()->AddTriggerId(200620); //L2 Gamma
    if(muEvent->triggerIdCollection().nominal().isTrigger(200621)==1) MEvent->GetHeader()->AddTriggerId(200621); //L2 Gamma
   
  }

  
  if(nflagData==2){
    //CuCu
    cout<<"CuCu set for both High Tower & MinBias"<<endl;
    Int_t keep = -999;
    //    StMuPrimaryVertex* fprimaryVertex = mu->primaryVertex();
    Float_t meanDip=mu->primaryVertex()->meanDip();
    Float_t ctbmult=muEvent->ctbMultiplicity();
    //float fmeanDip=fprimaryVertex->meanDip();
    
    if(mu->event()->refMult() >= 17) {
      if (fabs(meanDip/ctbmult) < (0.8/800))
	cout<<"keep event"<<endl;
      keep = 100;
    }
    
    if(muEvent->triggerIdCollection().nominal().isTrigger(66007)==1) MEvent->GetHeader()->AddTriggerId(66007);
    if(muEvent->triggerIdCollection().nominal().isTrigger(66203)==1) MEvent->GetHeader()->AddTriggerId(66203);

  }
  
  if(nflagData==3){
    //PP
    cout<<"PP set for both High Tower, JP and MinBias"<<endl;
    //mb
    if(muEvent->triggerIdCollection().nominal().isTrigger(117001)==1) MEvent->GetHeader()->AddTriggerId(117001);
    if(muEvent->triggerIdCollection().nominal().isTrigger(117201)==1) MEvent->GetHeader()->AddTriggerId(117201);
    
    //HT
    if(muEvent->triggerIdCollection().nominal().isTrigger(117211)==1) MEvent->GetHeader()->AddTriggerId(117211);
    if(muEvent->triggerIdCollection().nominal().isTrigger(117212)==1) MEvent->GetHeader()->AddTriggerId(117212);
    if(muEvent->triggerIdCollection().nominal().isTrigger(127212)==1) MEvent->GetHeader()->AddTriggerId(127212);
    if(muEvent->triggerIdCollection().nominal().isTrigger(127213)==1) MEvent->GetHeader()->AddTriggerId(127213);
    if(muEvent->triggerIdCollection().nominal().isTrigger(137213)==1) MEvent->GetHeader()->AddTriggerId(137213);
    
    //JP
    if(muEvent->triggerIdCollection().nominal().isTrigger(117221)==1) MEvent->GetHeader()->AddTriggerId(117221);
    if(muEvent->triggerIdCollection().nominal().isTrigger(127221)==1) MEvent->GetHeader()->AddTriggerId(127221);
    if(muEvent->triggerIdCollection().nominal().isTrigger(137221)==1) MEvent->GetHeader()->AddTriggerId(137221);
    if(muEvent->triggerIdCollection().nominal().isTrigger(137222)==1) MEvent->GetHeader()->AddTriggerId(137222);

  }

  if(nflagData==4 || nflagData==5){
    //d+Au
    cout<<"d+Au set"<<endl;
    //mb
    if(muEvent->triggerIdCollection().nominal().isTrigger(210020)==1) MEvent->GetHeader()->AddTriggerId(210020);
    
    //HT
     if(muEvent->triggerIdCollection().nominal().isTrigger(210500)==1) MEvent->GetHeader()->AddTriggerId(210500);
     if(muEvent->triggerIdCollection().nominal().isTrigger(210501)==1) MEvent->GetHeader()->AddTriggerId(210501);
     if(muEvent->triggerIdCollection().nominal().isTrigger(210510)==1) MEvent->GetHeader()->AddTriggerId(210510);
     if(muEvent->triggerIdCollection().nominal().isTrigger(210511)==1) MEvent->GetHeader()->AddTriggerId(210511);
     if(muEvent->triggerIdCollection().nominal().isTrigger(210520)==1) MEvent->GetHeader()->AddTriggerId(210520);
     if(muEvent->triggerIdCollection().nominal().isTrigger(210521)==1) MEvent->GetHeader()->AddTriggerId(210521);
     if(muEvent->triggerIdCollection().nominal().isTrigger(210541)==1) MEvent->GetHeader()->AddTriggerId(210541);
    
  }
  

  if(nflagData==8){
    //d+Au
    cout<<"p+p TOFMult4 set"<<endl;
    //TOFMult4
    if(muEvent->triggerIdCollection().nominal().isTrigger(370341)==1) MEvent->GetHeader()->AddTriggerId(370341);
  }
  
  Bfield  = 0.1*muEvent->runInfo().magneticField(); //this is in tesla,ie 0.1*kilogauss
   //cout<<"     ***** B Field = "<<Bfield<<endl; 
  StEventSummary &eventsum = muEvent->eventSummary();
  
   
  if(!mu->muEmcCollection()) return kStOk;      
  

  //cout<<"MEvent Test "<<MEvent<<endl;



  nPrimTrks=doPrimTrks();  

  //Barrel Time
   mEmcCol = (StEmcCollection*)mu->emcCollection();
   rBarrelPts = mEmcCol->barrelPoints().size();
   fNTOTMatchedTr=0;
   doCheckMatchedTracks();
   fMatchedTow=0;

  if (rBarrelPts >0) {
    nFlag = doTowerMatching();
  }
  else {
      nCand=0;
     nFlag=0;
    }  
 
  if(doV0) nV0s = doV0s();
  
  mTables->loadTables((StMaker*)this);
  
  //  cout<<" reaction plane  "<<GetReactionPlane()<<endl;
  rplane = GetReactionPlane();

  //---------------------- QA Histos -------------------------//
 //  if(nflagData==0 || nflagData==1) 
//     {
//       QAHist->hEventRefMult->Fill(muEvent->grefmult());
//       QAHist->hNMatchedvsRefMult->Fill(fNTOTMatchedTr,muEvent->grefmult());
//     }

//   else{
//     QAHist->hEventRefMult->Fill(muEvent->refMult());
//     QAHist->hNMatchedvsRefMult->Fill(fNTOTMatchedTr,muEvent->refMult());
//   }


//   QAHist->hEventVertexZ->Fill((eventsum.primaryVertexPosition()).z());
//   QAHist->hEventNPrim->Fill(mu->numberOfPrimaryTracks());
//   QAHist->hEventNPrimCut->Fill(MEvent->GetPrimaryTracks()->GetEntriesFast());
//   QAHist->hEventNTowers->Fill(rBarrelPts);
//   QAHist->hNMatched->Fill(fNTOTMatchedTr);
 
  

  //---eventlevel tree variables
  MEvent->GetHeader()->SetEventId(static_cast<Int_t>(muEvent->eventId()));
  MEvent->GetHeader()->SetRunId(static_cast<Int_t>(muEvent->runId()));
  MEvent->GetHeader()->SetReferenceMultiplicity(static_cast<Int_t>(muEvent->refMult()));
  MEvent->GetHeader()->SetGReferenceMultiplicity(static_cast<Int_t>(muEvent->grefmult()));
  MEvent->GetHeader()->SetNGlobalTracks(static_cast<Int_t>(mu->numberOfGlobalTracks()));
  MEvent->GetHeader()->SetReactionPlaneAngle(static_cast<Float_t>(rplane));
  MEvent->GetHeader()->SetNOfMatchedTowers(fMatchedTow);

  //MEvent->GetHeader()->SetNOfTowers(MEvent->GetTowers()->GetEntriesFast());
  //MEvent->GetHeader()->SetNOfPrimaryTracks(MEvent->GetPrimaryTracks()->GetEntriesFast());
  
  MEvent->GetHeader()->SetNOfMatchedTracks(fNTOTMatchedTr);

  //nofV0 -->Filled in TStarJetPicoEvent::AddV0
  //nofTrigObj-->Filled in TStarJetPicoEvent::AddTrig
  
  MEvent->GetHeader()->SetNOfEMCPoints(static_cast<Int_t>(rBarrelPts));
  MEvent->GetHeader()->SetPrimaryVertexX(static_cast<Float_t>((eventsum.primaryVertexPosition()).x()));  
  MEvent->GetHeader()->SetPrimaryVertexY(static_cast<Float_t>((eventsum.primaryVertexPosition()).y()));  
  MEvent->GetHeader()->SetPrimaryVertexZ(static_cast<Float_t>((eventsum.primaryVertexPosition()).z()));  
  MEvent->GetHeader()->SetCTBMultiplicity(muEvent->ctbMultiplicity());      
  MEvent->GetHeader()->SetPrimaryVertexMeanDipAngle(mu->primaryVertex(0)->meanDip());
  MEvent->GetHeader()->SetPrimaryVertexRanking(mu->primaryVertex(0)->ranking());
  MEvent->GetHeader()->SetNumberOfVertices(mu->primaryVertices()->GetEntries());
  MEvent->GetHeader()->SetDSMInput(muEvent->l0Trigger().dsmInput());
  MEvent->GetHeader()->SetTrigMask(muEvent->eventInfo().triggerMask());
  //  MEvent->Dump();

  //cut variables for dAu year 8
  MEvent->GetHeader()->SetZdcWestRate(static_cast<Float_t>(muEvent->runInfo().zdcWestRate()));
  MEvent->GetHeader()->SetZdcEastRate(static_cast<Float_t>(muEvent->runInfo().zdcEastRate()));
  MEvent->GetHeader()->SetZdcCoincidenceRate(static_cast<Float_t>(muEvent->runInfo().zdcCoincidenceRate()));
  MEvent->GetHeader()->SetBbcWestRate(static_cast<Float_t>(muEvent->runInfo().bbcWestRate()));
  MEvent->GetHeader()->SetBbcEastRate(static_cast<Float_t>(muEvent->runInfo().bbcEastRate()));
  MEvent->GetHeader()->SetBbcCoincidenceRate(static_cast<Float_t>(muEvent->runInfo().bbcCoincidenceRate()));
  MEvent->GetHeader()->SetBbcBlueBackgroundRate(static_cast<Float_t>(muEvent->runInfo().bbcBlueBackgroundRate()));
  MEvent->GetHeader()->SetBbcYellowBackgroundRate(static_cast<Float_t>(muEvent->runInfo().bbcYellowBackgroundRate()));
  MEvent->GetHeader()->SetBbcAdcSumEast(static_cast<Int_t>(muEvent->bbcTriggerDetector().adcSumEast()));


  //#ly StTriggerSimuMaker *simuTrig = (StTriggerSimuMaker*)GetMaker("StarTrigSimu");
  if(simuTrig)AddTriggerInfo(simuTrig);

  MTree->Fill();

  delete MEvent;
  return kStOK;

}
void StMuJetAnalysisTreeMaker::AddTriggerInfo(StTriggerSimuMaker *simuTrig){

  StMuTriggerIdCollection trig = muEvent -> triggerIdCollection();
  StTriggerId l1trig = trig.nominal();
  TStarJetPicoTriggerInfo trigobj;
  for (Int_t i_trig=0; i_trig<20; i_trig++) { 
    if (l1trig.triggerId(i_trig)!=0)
      cout << "test i trig   "<<i_trig<<"    "<<l1trig.triggerId(i_trig) << " (v " << l1trig.version(i_trig)<< ") "<<endl;
  }
  Int_t indHT=-1,nTrIds=-1;
  Int_t trId[10]={-999,-999,-999,-999,-999,-999,-999,-999,-999,-999};

  if(nflagData==0){//Au+Au HT triggers:
    trId[0]=200620; //L2 Gamma
    trId[1]=200621; //L2 Gamma
    trId[2]=200211;//bht2-mb
    trId[3]=200212;//bht2-mb
    trId[4]=200220;//bht2-mb
    trId[5]=200221;//bht2-mb
    trId[6]=200222;//bht2-mb
    
     nTrIds=7;
     indHT=6;
  }

  if(nflagData==4 || nflagData==5){//d+Au ALL and HT; only HT trigger used here
    trId[0]=210500;
    trId[1]=210501;
    trId[2]=210510;
    trId[3]=210511;
    trId[4]=210520;
    trId[5]=210521;
    trId[6]=210541;

    nTrIds=7;
    indHT=6;
  }

  
  
  if(nflagData==3){//pp
    
    trId[0]=117211;//first HT
    trId[1]=117212;//first HT
    trId[2]=127212;//first HT
    trId[3]=127213;//first HT
    trId[4]=137213;//first HT
    trId[5]=117221;// then JP
    trId[6]=127221;// then JP
    trId[7]=137221;// then JP
    trId[8]=137222;// then JP

    nTrIds=9;//n. of elem in trId array
    indHT=4;//index of last HT trigger id in the trId array
  }
  
  if(nflagData==8){//pp Y12
    
    trId[0]=370541;//BHT0*BBCMB*TOF0		BBCMB*TOF>0*BEMC High Tower 0 (11, Et>2.6 GeV), no FGT
    trId[1]=370542;//BHT0*BBCMB*TOF0
    trId[2]=370351;//MTD*BHT3			MTD * Barrel High Tower 3 (8, 1.9 GeV), no BSMD or FGT
    trId[3]=370601;//JP0			Barrel and Endcap Jet Patch 0 (20), no BSMD or FGT
    trId[4]=370611;//JP1			Barrel and Endcap Jet Patch 1 (28), no BSMD or FGT
    trId[5]=370621;//JP2			Barrel and Endcap Jet Patch 2 (36), no BSMD or FGT
    trId[6]=370011;//JP2			Barrel and Endcap Jet Patch 2 (36), no BSMD or FGT

    nTrIds=7;//n. of elem in trId array
    indHT=2;//index of last HT trigger id in the trId array
  }
  for(Int_t id=0;id<nTrIds;id++){
    Int_t trigId=l1trig.isTrigger(trId[id]);
    cout<<trId[id]<<" trigId = "<<trigId<<endl;
    StTriggerSimuResult trigResult = simuTrig->detailedResult(trId[id]);
    Float_t etaTow,phiTow;
    cout<<"isTrig = "<<simuTrig->isTrigger(trId[id])<<" BEMC="<<simuTrig->bemc->triggerDecision(trId[id])<<" "<<"trigResult.bemcDecision()= "<<trigResult.bemcDecision()<<" trigResult.l2Decision= "<<trigResult.l2Decision()<<endl;
    if (trigResult.bemcDecision()==1){
      if(id<=indHT && trigId==1 ){
	vector<short> towerId = trigResult.highTowerIds();
	for (unsigned i=0; i<towerId.size(); i++) {
	  cout<<" HT ********  LO Trigger BEMC Tower="<<towerId[i]<<" adc="<<trigResult.highTowerAdc(towerId[i])<<endl;
	  mGeom->getEtaPhi(towerId[i],etaTow,phiTow);
	  //TStarJetPicoTriggerInfo trigobj;
	  trigobj.Clear();
	  //trigobj.SetTriggerType("HTL0");
	  trigobj.SetEta(etaTow);
	  trigobj.SetPhi(phiTow);
	  trigobj.SetTriggerFlag(1);
	  trigobj.SetId(towerId[i]);
	  trigobj.SetADC(trigResult.highTowerAdc(towerId[i]));
	  MEvent->AddTrigObj(&trigobj);
	  
	  //build the TRIGGER OBJECT for HT L0
	  }
      }
      if(id>indHT && trigId==1 ){
	vector<short> towerId = trigResult.jetPatchIds();
	Float_t angle=-999;
	
	for (unsigned i=0; i<towerId.size(); i++) {
	  cout<<" JP ********  LO Trigger BEMC Tower="<<towerId[i]<<" adc="<<trigResult.jetPatchAdc(towerId[i])<<endl;
	  mGeom->getEtaPhi(towerId[i],etaTow,phiTow);
	  //TStarJetPicoTriggerInfo trigobj;
	  trigobj.Clear();
	  // trigobj.SetTriggerType("JPL0");
	  if(fTrigMap.Contains("2006-2008")){
	    if(towerId[i]<6){//WEST PART OF THE BEMC
	      angle=TMath::Pi()*5/6-TMath::Pi()/3*towerId[i];
	      if(angle<0)angle+=TMath::Pi()*2;
	      etaTow=0.5;
	    }
	    else{//EAST PART OF THE bemc
	      Int_t aux=towerId[i];
	      aux-=6;
	      angle=TMath::Pi()*5/6-TMath::Pi()/3*aux;
	      if(angle<0)angle+=TMath::Pi()*2;
	      etaTow=-0.5;
	    }
	  }
	  phiTow=angle;
	  //cout<<" --- > phi,eta = "<<phiTow<<"  "<<etaTow<<endl;
	  trigobj.SetEta(etaTow);
	  trigobj.SetPhi(phiTow);
	  trigobj.SetTriggerFlag(2);
	  trigobj.SetId(towerId[i]);
	  trigobj.SetADC(trigResult.jetPatchAdc(towerId[i]));
	  MEvent->AddTrigObj(&trigobj);
	  //build the TRIGGER OBJECT for HT L0
	}
      }
      
    }
      
      
    if (trigResult.l2Decision()==1){ //L2 decision=1 means true
      if(id<=indHT&& trigId==1){
	vector<short> towerId = trigResult.highTowerIds();
	for (unsigned i=0; i<towerId.size(); i++) {
	  cout<<" HT ********  L2 Trigger BEMC Tower="<<towerId[i]<<" adc="<<trigResult.highTowerAdc(towerId[i])<<endl;
	  mGeom->getEtaPhi(towerId[i],etaTow,phiTow);
	  trigobj.Clear();
	  //trigobj.SetTriggerType("HTL2");
	  trigobj.SetEta(etaTow);
	  trigobj.SetPhi(phiTow);
	  trigobj.SetTriggerFlag(3);
	  trigobj.SetId(towerId[i]);
	  trigobj.SetADC(trigResult.highTowerAdc(towerId[i]));
	  MEvent->AddTrigObj(&trigobj);
	  //build the TRIGGER OBJECT for HT L2
	}
      }
      if(id>indHT && trigId==1){
	vector<short> towerId = trigResult.jetPatchIds();
	Float_t angle=-999;
	for (unsigned i=0; i<towerId.size(); i++) {
	  cout<<" JP ********  L2 Trigger BEMC Tower="<<towerId[i]<<" adc="<<trigResult.jetPatchAdc(towerId[i])<<endl;
	  mGeom->getEtaPhi(towerId[i],etaTow,phiTow);
	  //TStarJetPicoTriggerInfo trigobj;
	  trigobj.Clear();
	  //trigobj.SetTriggerType("JPL2");
	  if(fTrigMap.Contains("2006-2008")){
	    if(towerId[i]<6){//WEST PART OF THE BEMC
	      angle=TMath::Pi()*5/6-TMath::Pi()/3*towerId[i];
	      etaTow=-0.5;
	    }
	    else{//EAST PART OF THE bemc
	      Int_t aux=towerId[i];
	      aux-=6;
	      angle=TMath::Pi()*5/6-TMath::Pi()/3*aux;
	      etaTow=0.5;
	    }
	  }
	  phiTow=angle;
	  trigobj.SetEta(etaTow);
	  trigobj.SetPhi(phiTow);
	  trigobj.SetTriggerFlag(4);
	  trigobj.SetId(towerId[i]);
	  trigobj.SetADC(trigResult.jetPatchAdc(towerId[i]));
	  MEvent->AddTrigObj(&trigobj);
	  //build the TRIGGER OBJECT for HT L0
	  
	}

      }
    }
    
    
  }

  // MTree->Fill();

  //delete MEvent;//moved here from Make
}
Int_t StMuJetAnalysisTreeMaker::doPrimTrks(){
  
  TStarJetPicoPrimaryTrack MpTrack;
  
  Float_t eta,  phi, flagval; 
  nTracks= mu->primaryTracks()->GetEntries();


  // nMTracks=fmtracklist->GetEntries();
  
  //muEvent = (StMuEvent*) mu->event();
  //StThreeVectorF vertex=muEvent->primaryVertexPosition();
 
  Int_t PrimTrks=0; 
  Int_t ncHit;
  //  Int_t keyC;
  // Int_t matchflag;

  fPrimIndexArray=new Int_t[nTracks];
 
  
  for (Int_t l=0; l<nTracks; l++) { 
    track =  (StMuTrack*) mu->primaryTracks(l); 
    //    if(track->dcaGlobal().mag()<1.5 && track->eta()<1.5 && track->eta()>-1.5 &&  track->flag() >= 0)
    //cout<<"track=  "<<l<<"  "<<fMatchTrArr[l]<<endl;    
    //    if(fMatchTrArr[l]==3)continue; //track is matched to EMC

    fPrimIndexArray[l]=-10;

    eta=track->eta();
    phi=track->phi();
    flagval=track->flag();
    ncHit=track->nHitsFit();
    // QAHist->hTrackNhits->Fill(ncHit);
      
    //      if(flagval >=0 && ncHit>fNHits && matchflag==0){
    if(flagval >=0 && ncHit>fNHits && track->dcaGlobal().mag()<2 && track->eta()<1.5 && track->eta()>-1.5){
      //cout<<"        "<<eta<<"  "<<phi<<"  "<<flagval<<"  "<<ncHit<<endl;
      //
      //QAHist->hTrackNhitsCut->Fill(ncHit);
      // QAHist->hTrackDCA->Fill(track->dcaGlobal().mag());
      // QAHist->hTrackEta->Fill(eta);
      // QAHist->hTrackPhi->Fill(phi);
      

      MpTrack.Clear();
      MpTrack.SetPx(static_cast<Float_t>(track->momentum().x()));      
      MpTrack.SetPy(static_cast<Float_t>(track->momentum().y()));      
      MpTrack.SetPz(static_cast<Float_t>(track->momentum().z())); 
	
      MpTrack.SetDCA(static_cast<Float_t>(track->dcaGlobal().mag()));
      MpTrack.SetdEdx(static_cast<Float_t>(track->dEdx()));
	
      MpTrack.SetNsigmaPion(static_cast<Float_t>(track->nSigmaPion()));
      MpTrack.SetNsigmaKaon(static_cast<Float_t>(track->nSigmaKaon()));
      MpTrack.SetNsigmaProton(static_cast<Float_t>(track->nSigmaProton()));
	
      MpTrack.SetCharge(static_cast<Int_t>(track->charge()));
      MpTrack.SetNOfFittedHits(static_cast<Int_t>(track->nHitsFit()));
      MpTrack.SetNOfPossHits(static_cast<Int_t>(track->nHitsPoss()));
      MpTrack.SetKey(static_cast<Int_t>(track->id()));
      fPrimIndexArray[PrimTrks]=l;
      MEvent->AddPrimaryTrack(&MpTrack);
      PrimTrks++;
    }
      
  }
  return PrimTrks;
}

Int_t StMuJetAnalysisTreeMaker::doCheckMatchedTracks(){
  
  cout << "----------- In doCheckMatchedTracks() -----------------" << endl;
  
    //before looping on all the towers: create an array with the index of tracks which have a projection to the BEMC
  
  Int_t nhitcheck,flagval;
  Int_t nTr=MEvent->GetHeader()->GetNOfPrimaryTracks();

 //  nTracks= mu->primaryTracks()->GetEntries(); 
 //  const Int_t nTr=nTracks;
  
  fMatchTrArr=new Int_t[nTr];
  fMatchTrEtaArr=new Float_t[nTr];
  fMatchTrPhiArr=new Float_t[nTr];
  fPrimEtaArray=new Float_t[nTr];
  fPrimPhiArray=new Float_t[nTr];

  for(Int_t i=0;i<nTr;i++){
    fMatchTrArr[i]=-10;
    fMatchTrEtaArr[i]=-10.;
    fMatchTrPhiArr[i]=-10.;
    fPrimEtaArray[i]=-10.;
    fPrimPhiArray[i]=-10.;
  }


  Int_t nMatched=0,n1=0,n2=0,n3=0;

  for(Int_t tr =0; tr<nTr; tr++) 
    {//loop over tracks
      Int_t l=fPrimIndexArray[tr];
      track =  (StMuTrack*) mu->primaryTracks(l); 
      nhitcheck=track->nHitsFit();
      StThreeVectorD momentum,position;
      StEmcPosition *mPosition = new StEmcPosition();
      flagval=track->flag();

      nhitcheck=track->nHitsFit();
      n1++;   
      if(flagval<0 || nhitcheck<fNHits+1) {
	delete mPosition;
	continue;
      }
      n2++;

      bool proj_ok= mPosition->projTrack(&position,&momentum,track,(Double_t) Bfield); 
      
      Float_t z,eta,phi;
      eta =position.pseudoRapidity(); 
      phi =position.phi();
      z   =position.z();
      Int_t m,e,s;
      Int_t okbin=mGeom->getBin(phi,eta,m,e,s);
      if (s <0 || okbin==1) {
	delete mPosition;
	continue;
      }
      n3++;
      
      if (proj_ok){
	fMatchTrArr[tr]=1;
	fMatchTrEtaArr[tr]=eta;
	fMatchTrPhiArr[tr]=phi;
	fPrimEtaArray[tr]=track->eta();
	fPrimPhiArray[tr]=track->phi();
	nMatched++;
      }

      delete mPosition;
    }


  printf("Primary track # = %d and projected to BEMC # = %d \n",nTracks, nMatched);
  cout<<"n1,n2,n3="<<n1<<"  "<<n2<<"  "<<n3<<endl;

  return nMatched;
}

Int_t StMuJetAnalysisTreeMaker::doV0s(){

  TStarJetPicoV0 MpV0;
  StV0MuDst *v0MuDst;
  StMuTrack *globTrk;
  Int_t v0=0;
  Int_t posFound, negFound;

  Int_t nV0sMuDst = mu->v0s()->GetEntries();
  
  for (Int_t l=0; l<nV0sMuDst; l++) { 
    v0MuDst =  (StV0MuDst*) mu->v0s(l); 

    if( fTCutV0->CheckV0(v0MuDst, mu) == 1){
      MpV0.Clear();
      MpV0.SetPxPos(static_cast<Float_t>(v0MuDst->momPosX()));
      MpV0.SetPyPos(static_cast<Float_t>(v0MuDst->momPosY()));
      MpV0.SetPzPos(static_cast<Float_t>(v0MuDst->momPosZ()));
      MpV0.SetPxNeg(static_cast<Float_t>(v0MuDst->momNegX()));
      MpV0.SetPyNeg(static_cast<Float_t>(v0MuDst->momNegY()));
      MpV0.SetPzNeg(static_cast<Float_t>(v0MuDst->momNegZ()));
      MpV0.SetKeyPos(static_cast<Int_t>(v0MuDst->keyPos()));
      MpV0.SetKeyNeg(static_cast<Int_t>(v0MuDst->keyNeg()));
      MpV0.SetDcapn(static_cast<Int_t>(v0MuDst->dcaV0Daughters()));
      MpV0.SetDcaV0(static_cast<Float_t>(v0MuDst->dcaV0ToPrimVertex()));
      MpV0.SetDcaPos(static_cast<Float_t>(v0MuDst->dcaPosToPrimVertex()));
      MpV0.SetDcaNeg(static_cast<Float_t>(v0MuDst->dcaNegToPrimVertex()));
      MpV0.SetDecayLength(static_cast<Float_t>(v0MuDst->decayLengthV0()));
      MpV0.SetDedxPos(static_cast<Float_t>(v0MuDst->dedxPos()));
      MpV0.SetDedxNeg(static_cast<Float_t>(v0MuDst->dedxNeg()));

      posFound = 0;
      negFound = 0;
      for(Int_t glob=0; glob<mu->globalTracks()->GetEntries(); glob++){
	globTrk =  mu->globalTracks(glob);
	if( globTrk->id() == v0MuDst->keyPos()){
	  posFound = 1;
	  MpV0.SetNSigmaPionPos(static_cast<Float_t>(globTrk->nSigmaPion()));
	  MpV0.SetNSigmaProtonPos(static_cast<Float_t>(globTrk->nSigmaProton()));
	}
	if( globTrk->id() == v0MuDst->keyNeg()){
	  negFound = 1;
	  MpV0.SetNSigmaPionNeg(static_cast<Float_t>(globTrk->nSigmaPion()));
	  MpV0.SetNSigmaProtonNeg(static_cast<Float_t>(globTrk->nSigmaProton()));
	}
	if( negFound==1 && posFound ==1) break;
      }

      MEvent->AddV0(&MpV0);
      v0++;
    }
  }

  cout << "saving " << v0 << " out of " << nV0sMuDst << endl;
  return v0;  

}

Double_t StMuJetAnalysisTreeMaker::GetReactionPlane()
{ cout << "----------- In GetReactionPlane() -----------------" << endl;
 TVector2 mQ;
 Double_t mQx=0., mQy=0.;
 Double_t order = 2; Int_t n,i;
 n=mu->primaryTracks()->GetEntries();
 for (i=0; i<n; i++) {
   track = (StMuTrack*) mu->primaryTracks(i);   // get pointer to primary track
   Float_t phi = track->phi();
   mQx += cos(phi * order);
   mQy += sin(phi * order);
 }
 
 mQ.Set(mQx, mQy);
 Double_t psi= mQ.Phi() / order;
 Float_t pi=TMath::Pi();
 return psi*180/pi;
}


Int_t StMuJetAnalysisTreeMaker::doTowerMatching(){

  cout << "----------- In doTowerMatching() -----------------" << endl;
  StBemcTables* tables = mTables;
  assert(tables);
  
  Int_t flag=0;
  mEmcCol = (StEmcCollection*)mu->emcCollection();
  StMuEmcCollection* muEmcCol = mu->muEmcCollection();
  
  if(!mEmcCol || !muEmcCol)
    {
      printf("\n***-- no EMC Collection was found --***\n"); 
      return 1;
    }
    

  StSPtrVecEmcPoint& container =  mEmcCol->barrelPoints();

  if(mEmcCol->barrelPoints().size()==0 || container.size()==0){
    cout<<"In doTrack Matching no container or no size"<<endl;
    return -1;
  }
  TStarJetPicoTower allTower;
  TStarJetPicoPrimaryTrack mTrack;
  //  allTower.SetObjArray();

  rBarrelPts = mEmcCol->barrelPoints().size();
  StEmcDetector* detector;
  
  detector=mEmcCol->detector(kBarrelEmcTowerId);
 

  Float_t etaTower, phiTower;
  if(detector) {
    Int_t mm = 0, ee = 0, ss = 0;	 
    Int_t statusAll  =-99;
    Int_t towerId = 0;
    fMatchedTow=0;

    // cout<<" counts   "<<fmtowerlist->GetEntries()<<endl;

    for (UInt_t i = 1; i < 121; i++){
      StSPtrVecEmcRawHit& emcTowerHits = detector->module(i)->hits();

      for (UInt_t j = 0; j < emcTowerHits.size(); j++){
	mm = (Int_t)emcTowerHits[j]->module();
	ee = (Int_t)emcTowerHits[j]->eta();
	ss = emcTowerHits[j]->sub();
	
	if(abs(mm)<=120&&abs(ee)<=20&&ss<=2)	 {
	  
	  mGeom->getId(mm, ee, ss, towerId);
	  tables->getStatus(BTOW, towerId, statusAll);
	  
	  if(statusAll==1){
	
	    //  Int_t matchflagtow;
	    Float_t energyTowerAll=emcTowerHits[j]->energy();
	    Float_t ADCTower=emcTowerHits[j]->adc();
	  
	    if(energyTowerAll<0.15)continue;//added new Fri Oct31 08
	    mGeom->getEtaPhi(towerId,etaTower,phiTower);
	    
	    // 	    if(matchflagtow==1 || energyTowerAll<=0.) continue;
	    //   if(energyTowerAll<=0) continue;
	    Int_t didT=towerId;
	    

	    if(nflagData==0 || nflagData==1){ //cout<<"Twr Id Check for hot towers"<<endl;
	    
	      if(didT==1433||didT==3407||didT==3711||didT==3720||didT==3840||didT==1130||didT==1132||didT==114||didT==1197||didT==1257||didT==1274 ||didT==1278 ||didT==1294||didT==1300||didT==1319||didT==1348||didT==1350||didT==1428||didT==1537||didT==1666||didT==1709||didT==1791||didT==1871||didT==1909||didT==2066||didT==2313||didT==308 ||didT==3364||didT==3375||didT==3420||didT==3428||didT==3740||didT==4132||didT==4152||didT==4262||didT==4422||didT==4453||didT==4498||didT==4691||didT==509||didT==576||didT==59||didT==591||didT==636||didT==707||didT==740||didT==762||didT==779 ||didT==830||didT==887 ||didT==899||didT==972) 
		continue;
	    }
	    
	    Int_t ehits,phits;
	    StEmcCluster* closeclust1 = findSMDCluster(etaTower,phiTower,2);//SmdE
	    if (closeclust1 !=NULL) {
	      ehits = SMDHits(2,clusterid);
	    }
	    StEmcCluster* closeclust2 = findSMDCluster(etaTower,phiTower,3);//smdP
	    if (closeclust2 !=NULL) {
	      phits = SMDHits(3,clusterid);
	    }

	    //Correction of PVZ shift
 
	    Float_t etaC, T1;
	    T1=2*atan(exp(-etaTower));
	    Double_t zNew;
	    if(etaTower!=0){zNew=231/tan(T1);} //231 cm = radius SMD
	    if(etaTower==0){zNew=0;}
	    Double_t zNom=zNew-PrimVertexZ;
	    Double_t THETA=atan2(231,zNom);
	    etaC=-log(tan(THETA/2));

	    allTower.Clear();
	    allTower.SetPhi(static_cast<Float_t>(phiTower));
	    allTower.SetEta(static_cast<Float_t>(etaTower));
	    allTower.SetId(static_cast<Int_t>(towerId));
	    allTower.SetEnergy(static_cast<Float_t>(energyTowerAll));
	    allTower.SetADC(static_cast<Int_t>(ADCTower));
	    allTower.SetPhiCorrected(static_cast<Float_t>(phiTower)); //Not really corrected as no change is expected
	    allTower.SetEtaCorrected(static_cast<Float_t>(etaC));
	 
	    allTower.SetSMDClusterP(static_cast<Int_t>(phits));
	    allTower.SetSMDClusterE(static_cast<Int_t>(ehits));
   	    allTower.SetTowerStatus(static_cast<Int_t>(statusAll));
	    Double_t ettower=energyTowerAll/TMath::CosH(etaC);

	    //   QAHist->hTowerEta->Fill(etaTower);
	    // QAHist->hTowerPhi->Fill(phiTower);
	    
	    // QAHist->hTowerEtaC->Fill(etaC);
	    // QAHist->hTowerET->Fill(ettower);
	   
	    
	    Int_t count=0;
	    Int_t Nofprim=MEvent->GetHeader()->GetNOfPrimaryTracks();

	    
	    for(Int_t tr =0; tr<Nofprim; tr++) //this is nCand
	      {
		if(fMatchTrArr[tr]==1){

		  Float_t etaE,phiE,eta,phi;
		  etaE=fMatchTrEtaArr[tr];
		  phiE=fMatchTrPhiArr[tr];
		  eta=fPrimEtaArray[tr];
		  phi=fPrimPhiArray[tr];

 		  Float_t dphi = phiE - phiTower;
 		  Float_t deta = etaE - etaTower;

		  // QAHist->hDeltaEtaDeltaPhiProj->Fill(deta,dphi);

		  //cout<< " dphi  "<<dphi<<"  deta  "<<deta<<endl;
		  if (fabs(dphi) > 0.025) continue;
		  if (fabs(deta) > 0.025) continue;
		  // QAHist->hDeltaEtaDeltaPhiProjAcc->Fill(deta,dphi);

		  Int_t l=fPrimIndexArray[tr];
		  track =  (StMuTrack*) mu->primaryTracks(l); 
		  
		  Double_t trackorphi=track->phi();
		  Double_t trackoreta=track->eta();
		  Double_t diffeta=trackoreta-eta;
		  Double_t diffphi=trackorphi-phi;


		  if(diffeta!=0 || diffphi!=0) {
		    cout<<"==== DoTowerMatching ==== Sanity Check: Problem with the matched index "<<endl;
		    //QAHist->hEtaDiff->Fill(diffeta);
		    // QAHist->hPhiDiff->Fill(diffphi);

		  }
		  

		  Double_t pttrack=track->pt();
		  //Float_t POverE=-99;
		  
		  //POverE=TStarJetPicoUtils::GetTowerPoverE(MEvent,&allTower,tr);
		  //mTrack.Clear();
		  //mTrack.SetPx(track->momentum().x());
		  //mTrack.SetPy(track->momentum().y());
		  //mTrack.SetPz(track->momentum().z());
		  //POverE=TStarJetPicoUtils::GetTowerPoverE(&allTower,&mTrack);
		  
		  Float_t Pz=track->momentum().z();
		  Float_t POverE=TMath::Sqrt(pttrack*pttrack+Pz*Pz)/energyTowerAll;
		  //cout<<"POverE   "<<POverE<<"    "<<POverEMine<<endl;
		//   QAHist->hTrackPoverE->Fill(POverE);
// 		  QAHist->hPtvsEtMatched->Fill(pttrack,ettower);
// 		  QAHist->hEtaMEtaT->Fill(eta,etaTower);
// 		  QAHist->hPhiMPhiT->Fill(phi,phiTower);
// 		  QAHist->hEtaDeltaEta->Fill(eta,deta);
// 		  QAHist->hPhiDeltaPhi->Fill(phi,dphi);
		  
		    
		  // mTrack.SetEtaDiffHitProjected(static_cast<Float_t>(deta));
		  // mTrack.SetPhiDiffHitProjected(static_cast<Float_t>(dphi));
		  
		  count++;
		  fNTOTMatchedTr++;
		  allTower.AddMatchedTrack(tr); 
		  fMatchTrArr[tr]=3;
		  //delete mPosition;
		}
	      }
	    MEvent->AddTower(&allTower);
	    flag++;
	    if(allTower.GetNAssocTracks()>0) fMatchedTow++;
	  }
	}
      }
    }
  }
  
  else {
    printf("no detector in EMC collection id \n");
  }
  
  cout<<"number of total associated tracks in the event = "<<fNTOTMatchedTr<<"  N of Towers with at least 1 matched track = "<<fMatchedTow<<endl;
  printf("Out StMuJetAnalysisTreeMaker:doMatchedTower \n");
  return flag;
}


StEmcCluster* StMuJetAnalysisTreeMaker::findSMDCluster(Float_t eta, Float_t phi,Int_t det)
{
  if(mVerbose)cout << "----------- In findSMDCluster() -----------------" << endl;
  //looking for corresponding cluster in SMD detector (det=2 SMDe, det=3 SMDp) with eta,phi of
  // TPC track
  StEmcCluster *clusterSMD = NULL;
  clusterid = -1;
  Float_t dmin = 9999;
  Float_t dmin_cut = 0.05; //this is cut on difference of SMD cluster eta,phi difference from TPC eta,phi 
  
  StDetectorId id = static_cast<StDetectorId>(det+kBarrelEmcTowerId);
  StEmcDetector* detector=mEmcCol->detector(id);
  if(detector) {
    StEmcClusterCollection* clusters = detector->cluster();
    if(clusters) {
      StSPtrVecEmcCluster& cl=clusters->clusters();
      //if(mVerbose) printf("number of SMD det %i clusters %i\n",det,cl.size());
      if(cl.size()>0) {
	for(Int_t i=0;i<(Int_t)cl.size();i++) if(cl[i]) { 
	  //going over all cluster
	  Float_t ETA = cl[i]->eta();
	  Float_t PHI = cl[i]->phi();
	  Float_t d = sqrt((eta-ETA)*(eta-ETA)+(phi-PHI)*(phi-PHI));
	  
	  if(d<dmin) {
	    //storing clusters with up to now best matching
	    dmin = d;
	    clusterid = i; 
	  }
	}//loop over clusters    
      }
      
      if(dmin<dmin_cut && clusterid!=-1) {
	clusterSMD = cl[clusterid];
	if(mVerbose)cout <<"Found SMD cluster for detector "<<det<<"\t distance="<< dmin << endl;
      
      }
    }//if clusters !NULL
  }//if detector !NULL
  
  return clusterSMD;
}


Int_t  StMuJetAnalysisTreeMaker::SMDHits(Int_t det, Int_t clustid)
{
  //looking for corresponding cluster in SMD detector (det=2 SMDe, det=3 SMDp) with eta,phi of
  Int_t nhits=0;
  StDetectorId id = static_cast<StDetectorId>(det+kBarrelEmcTowerId);
  StEmcDetector* detector=mEmcCol->detector(id);
  if(detector) {
    StEmcClusterCollection* clusters = detector->cluster();
    if(clusters) {
      StSPtrVecEmcCluster& cl=clusters->clusters();
      nhits = cl[clustid]->nHits();
    }    
  }
  return nhits;
}
